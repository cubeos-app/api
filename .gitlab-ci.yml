# =============================================================================
# CubeOS API Pipeline - Build, Package, Deploy
# =============================================================================
stages:
  - lint
  - test
  - build
  - package
  - deploy

variables:
  GOPROXY: "https://proxy.golang.org,direct"
  GHCR_IMAGE: "ghcr.io/cubeos-app/api"
  BUILDER_IMAGE: "ghcr.io/cubeos-app/api-builder:latest"

# -----------------------------------------------------------------------------
# LINT
# -----------------------------------------------------------------------------
lint:
  stage: lint
  tags: [multiarch]
  image: ${BUILDER_IMAGE}
  script:
    - cp -r . /app/
    - cd /app
    - go vet ./...
    - test -z "$(gofmt -l . | grep -v vendor)" || (echo "Code not formatted" && gofmt -l . && exit 1)
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# TEST
# -----------------------------------------------------------------------------
test:
  stage: test
  tags: [multiarch]
  image: ${BUILDER_IMAGE}
  script:
    - cp -r . /app/
    - cd /app
    - go clean -modcache
    - go mod download
    - go test -v -coverprofile=coverage.out ./...
    - cp coverage.out ${CI_PROJECT_DIR}/ || true
  artifacts:
    paths:
      - coverage.out
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

verify-routes:
  stage: test
  tags: [multiarch]
  image: ${BUILDER_IMAGE}
  before_script:
    - apk add --no-cache bash grep
  script:
    - cp -r . /app/
    - cd /app
    - go install github.com/swaggo/swag/cmd/swag@latest
    - export PATH=$PATH:$(go env GOPATH)/bin
    - swag init --generalInfo cmd/cubeos-api/main.go --dir ./ --output docs --parseDependency --parseInternal
    - bash scripts/verify-routes.sh
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# BUILD - Generate Swagger docs and compile binaries
# -----------------------------------------------------------------------------
build:
  stage: build
  tags: [multiarch]
  image: ${BUILDER_IMAGE}
  script:
    - cp -r . /app/
    - cd /app
    - go clean -modcache
    - go mod download
    - go install github.com/swaggo/swag/cmd/swag@latest
    - export PATH=$PATH:$(go env GOPATH)/bin
    - |
      echo "ðŸ“ Generating Swagger documentation..."
      swag init \
        --generalInfo cmd/cubeos-api/main.go \
        --dir ./ \
        --output docs \
        --parseDependency \
        --parseInternal
    - ls -la docs/
    - GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="-s -w -X main.Version=${CI_COMMIT_SHORT_SHA}" -o cubeos-api-arm64 ./cmd/cubeos-api/
    - GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w -X main.Version=${CI_COMMIT_SHORT_SHA}" -o cubeos-api-amd64 ./cmd/cubeos-api/
    - cp cubeos-api-arm64 cubeos-api-amd64 ${CI_PROJECT_DIR}/
    - cp -r docs ${CI_PROJECT_DIR}/
    - ls -lh ${CI_PROJECT_DIR}/cubeos-api-*
    - echo "âœ… Swagger docs generated and binaries built"
  artifacts:
    paths:
      - cubeos-api-arm64
      - cubeos-api-amd64
      - docs/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# PACKAGE - Build multi-arch Docker image and push to ghcr.io
# -----------------------------------------------------------------------------
package:
  stage: package
  tags: [multiarch]
  image: docker:24
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
    - docker buildx create --name mybuilder --driver docker-container --use
    - docker buildx inspect --bootstrap
  script:
    - |
      docker buildx build --no-cache \
        --platform linux/amd64,linux/arm64 \
        --push \
        -t ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} \
        -t ${GHCR_IMAGE}:latest \
        .
    - echo "âœ… Pushed multi-arch ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
  after_script:
    - docker buildx rm mybuilder || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# DEPLOY - Host-mode Swarm service deployment (robust)
# -----------------------------------------------------------------------------
# Host-mode ports require the old container to fully stop before the new one
# can bind. This deploy stage handles three failure modes:
#
#   1. Port held by zombie container â†’ force-remove before update
#   2. Service stuck at 0/1 from previous failure â†’ recover and redeploy
#   3. Service deleted entirely â†’ fresh stack deploy
#
# CRITICAL: Never use --detach=false with host-mode services. Swarm retries
# indefinitely when the port is held, blocking the CI runner until job timeout.
# Instead, deploy detached and poll the health endpoint ourselves.
# -----------------------------------------------------------------------------
deploy:
  stage: deploy
  tags: [arm64, cubeos, deploy]
  timeout: 5m
  variables:
    SERVICE_NAME: "cubeos-api_cubeos-api"
    STACK_NAME: "cubeos-api"
    HOST_PORT: "6010"
    COMPOSE_PATH: "/cubeos/coreapps/cubeos-api/appconfig/docker-compose.yml"
    HEALTH_TIMEOUT: "60"
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
  script:
    - echo "ðŸš€ Deploying CubeOS API (commit ${CI_COMMIT_SHORT_SHA})..."

    # =========================================================================
    # Pre-flight: verify Docker iptables chains are healthy
    # =========================================================================
    - |
      echo "ðŸ” Pre-flight: checking Docker networking health..."
      if ! sudo iptables -t nat -L DOCKER -n > /dev/null 2>&1; then
        echo "âš ï¸  DOCKER nat chain missing â€” restarting Docker to recreate..."
        sudo systemctl restart docker
        sleep 15
        if ! sudo iptables -t nat -L DOCKER -n > /dev/null 2>&1; then
          echo "âŒ DOCKER nat chain still missing after restart. Manual intervention required."
          exit 1
        fi
        echo "âœ… Docker networking restored"
      else
        echo "âœ… Docker networking healthy"
      fi

    # Pull the new image first (before touching the running service)
    - docker pull ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
    - docker tag ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} ${GHCR_IMAGE}:latest

    # =========================================================================
    # Pre-flight: kill zombie containers holding the port
    # =========================================================================
    # After a failed deploy, Swarm may leave a stopped/dead task whose
    # docker-proxy still holds the host port. Find and force-remove it.
    - |
      echo "ðŸ” Pre-flight: checking for zombie containers on port ${HOST_PORT}..."
      PORT_PID=$(ss -tlnp | grep ":${HOST_PORT} " | grep -oP 'pid=\K\d+' | head -1)
      if [ -n "${PORT_PID}" ]; then
        # Find which container owns this docker-proxy
        ZOMBIE=$(docker ps -a --format '{{.ID}} {{.Names}} {{.Status}}' | grep -i "cubeos-api" || true)
        if [ -n "${ZOMBIE}" ]; then
          echo "  Found container(s) on port ${HOST_PORT}:"
          echo "  ${ZOMBIE}"
          # Check if the running container is already on the target image
          RUNNING_IMAGE=$(docker ps --filter "name=cubeos-api" --format '{{.Image}}' | head -1)
          if [ "${RUNNING_IMAGE}" = "${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}" ]; then
            echo "  âœ… Already running target image â€” skipping update"
            # Jump straight to health check
            SKIP_UPDATE=true
          fi
        fi
      else
        echo "  âœ… Port ${HOST_PORT} is free"
      fi

    # Show current state
    - |
      echo "ðŸ“Š Current state:"
      docker service ls | grep ${STACK_NAME} || echo "  No existing services found"

    # =========================================================================
    # Deploy: detached update + health poll (never --detach=false)
    # =========================================================================
    - |
      if [ "${SKIP_UPDATE}" = "true" ]; then
        echo "â­ï¸  Skipping update â€” correct image already running"
      elif docker service inspect ${SERVICE_NAME} > /dev/null 2>&1; then
        echo "ðŸ“¦ Service exists â€” updating image (detached)..."

        # Force-remove any shutdown/failed tasks first to free the port.
        # This handles the case where Swarm left a dead task with port held.
        docker service update \
          --image ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} \
          --update-order stop-first \
          --force \
          --detach \
          ${SERVICE_NAME}

        echo "  â³ Update issued (detached) â€” will poll health endpoint..."
        # Give Swarm a moment to stop old task and start new one
        sleep 5
      else
        echo "ðŸ“¦ Service doesn't exist â€” deploying fresh stack..."
      fi

    # =========================================================================
    # Recovery: if service vanished (previous failed deploy nuked it),
    # redeploy the full stack from compose
    # =========================================================================
    - |
      if [ "${SKIP_UPDATE}" != "true" ] && ! docker service inspect ${SERVICE_NAME} > /dev/null 2>&1; then
        echo "ðŸ†• Service not found â€” deploying stack from compose..."

        # Force-kill any orphan containers still holding the port
        ORPHANS=$(docker ps -a -q --filter "name=cubeos-api")
        if [ -n "${ORPHANS}" ]; then
          echo "  ðŸ§¹ Removing orphan containers..."
          echo "${ORPHANS}" | xargs docker rm -f 2>/dev/null || true
        fi

        # Wait for port to actually be released
        for i in $(seq 1 15); do
          if ! ss -tlnp | grep -q ":${HOST_PORT} "; then
            echo "  âœ… Port ${HOST_PORT} is free"
            break
          fi
          if [ "$i" = "15" ]; then
            echo "  âš ï¸  Port ${HOST_PORT} still held â€” killing docker-proxy..."
            PORT_PID=$(ss -tlnp | grep ":${HOST_PORT} " | grep -oP 'pid=\K\d+' | head -1)
            [ -n "${PORT_PID}" ] && sudo kill -9 "${PORT_PID}" 2>/dev/null || true
            sleep 2
          fi
          echo "  Waiting for port ${HOST_PORT} to be released... ($i/15)"
          sleep 2
        done

        docker stack deploy \
          --compose-file ${COMPOSE_PATH} \
          --resolve-image never \
          ${STACK_NAME}

        echo "  â³ Stack deployed â€” waiting for service registration..."
        sleep 8

        # Pin to exact commit image (detached)
        if docker service inspect ${SERVICE_NAME} > /dev/null 2>&1; then
          echo "  ðŸ”„ Pinning to commit image..."
          docker service update \
            --image ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} \
            --update-order stop-first \
            --detach \
            ${SERVICE_NAME}
          sleep 5
        fi
      fi

    # =========================================================================
    # Health check: poll until healthy (controlled timeout, not Swarm's)
    # =========================================================================
    - |
      echo ""
      echo "â³ Waiting for API to be healthy (timeout: ${HEALTH_TIMEOUT}s)..."
      HEALTH_URL="http://127.0.0.1:${HOST_PORT}/health"
      SECONDS_WAITED=0
      INTERVAL=3

      while [ ${SECONDS_WAITED} -lt ${HEALTH_TIMEOUT} ]; do
        RESPONSE=$(curl -sf ${HEALTH_URL} 2>/dev/null) && {
          echo ""
          echo "âœ… Health check passed after ${SECONDS_WAITED}s!"
          echo "   Response: ${RESPONSE}"
          echo ""
          echo "=== Deployment Summary ==="
          echo "Image:   ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
          echo "Service: ${SERVICE_NAME}"
          echo ""
          docker service ls | grep ${STACK_NAME}
          echo ""
          echo "ðŸ“š Swagger UI: http://cubeos.cube:${HOST_PORT}/api/v1/docs/index.html"
          exit 0
        }

        SECONDS_WAITED=$((SECONDS_WAITED + INTERVAL))

        # Every 15s, print service task status for visibility
        if [ $((SECONDS_WAITED % 15)) -eq 0 ]; then
          echo "  â³ ${SECONDS_WAITED}s â€” checking task status..."
          docker service ps ${SERVICE_NAME} --no-trunc --format '{{.CurrentState}} {{.Error}}' 2>/dev/null | head -3 || true
          # If task shows "port already in use", force-kill and retry
          TASK_ERR=$(docker service ps ${SERVICE_NAME} --no-trunc --format '{{.Error}}' 2>/dev/null | head -1)
          if echo "${TASK_ERR}" | grep -qi "port already in use"; then
            echo "  âš ï¸  Port conflict detected â€” killing holders and forcing update..."
            docker ps -a -q --filter "name=cubeos-api" | xargs docker rm -f 2>/dev/null || true
            sleep 2
            docker service update --force --detach ${SERVICE_NAME} 2>/dev/null || true
            sleep 3
          fi
        else
          echo "  â³ ${SECONDS_WAITED}/${HEALTH_TIMEOUT}s..."
        fi
        sleep ${INTERVAL}
      done

      # =====================================================================
      # Health check failed â€” diagnostics
      # =====================================================================
      echo ""
      echo "âŒ Health check failed after ${HEALTH_TIMEOUT}s"
      echo ""
      echo "=== Diagnostics ==="
      echo "Service status:"
      docker service ls | grep ${STACK_NAME} || echo "  Stack not found"
      echo ""
      echo "Service tasks:"
      docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null | head -5 || echo "  Service not found"
      echo ""
      echo "Recent logs:"
      docker service logs ${SERVICE_NAME} --tail 30 2>/dev/null || echo "  No logs available"
      echo ""
      echo "Port status:"
      ss -tlnp | grep ${HOST_PORT} || echo "  Port ${HOST_PORT} not listening"
      echo ""
      echo "iptables DOCKER chain:"
      sudo iptables -t nat -L DOCKER -n 2>&1 | head -5
      echo ""
      exit 1

  environment:
    name: production
    url: http://nllei01mule01:6010
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
