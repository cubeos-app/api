package managers

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"cubeos-api/internal/config"
	"cubeos-api/internal/models"
)

// FirewallManager handles iptables firewall operations
type FirewallManager struct {
	cfg *config.Config
}

// NewFirewallManager creates a new FirewallManager
func NewFirewallManager(cfg *config.Config) *FirewallManager {
	return &FirewallManager{cfg: cfg}
}

// GetStatus returns complete firewall status
func (m *FirewallManager) GetStatus() map[string]interface{} {
	return map[string]interface{}{
		"filter_rules":     m.GetUserRules("filter"),
		"nat_rules":        m.GetUserRules("nat"),
		"all_filter_rules": m.GetRules("filter"),
		"all_nat_rules":    m.GetRules("nat"),
		"nat_enabled":      m.isNATEnabled(),
		"ip_forward":       m.isIPForwardEnabled(),
	}
}

// GetRules returns all rules in a table
func (m *FirewallManager) GetRules(table string) []models.FirewallRule {
	var rules []models.FirewallRule

	cmd := exec.Command("iptables", "-t", table, "-L", "-n", "-v", "--line-numbers")
	output, err := cmd.Output()
	if err != nil {
		return rules
	}

	var currentChain string
	scanner := bufio.NewScanner(strings.NewReader(string(output)))
	for scanner.Scan() {
		line := scanner.Text()

		// Detect chain header
		if strings.HasPrefix(line, "Chain ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				currentChain = parts[1]
			}
			continue
		}

		// Skip header lines
		if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "pkts") || line == "" {
			continue
		}

		rule := m.parseIptablesLine(line, currentChain)
		if rule.Chain != "" {
			rules = append(rules, rule)
		}
	}

	return rules
}

// GetUserRules returns only user-defined rules (filters out Docker auto-generated rules)
func (m *FirewallManager) GetUserRules(table string) []models.FirewallRule {
	allRules := m.GetRules(table)
	var userRules []models.FirewallRule

	for _, rule := range allRules {
		if m.isDockerRule(rule) {
			continue
		}
		userRules = append(userRules, rule)
	}

	return userRules
}

// isDockerRule checks if a rule is auto-generated by Docker
func (m *FirewallManager) isDockerRule(rule models.FirewallRule) bool {
	// Skip Docker chains
	dockerChains := []string{"DOCKER", "DOCKER-ISOLATION-STAGE-1", "DOCKER-ISOLATION-STAGE-2", "DOCKER-USER"}
	for _, chain := range dockerChains {
		if rule.Chain == chain || rule.Target == chain {
			return true
		}
	}

	// Skip rules involving Docker interfaces
	if strings.HasPrefix(rule.InterfaceIn, "docker") ||
		strings.HasPrefix(rule.InterfaceOut, "docker") ||
		strings.HasPrefix(rule.InterfaceIn, "br-") ||
		strings.HasPrefix(rule.InterfaceOut, "br-") ||
		strings.HasPrefix(rule.InterfaceIn, "veth") ||
		strings.HasPrefix(rule.InterfaceOut, "veth") {
		return true
	}

	// Skip rules to Docker subnets (172.17.0.0/16, 172.18.0.0/16, etc.)
	if strings.HasPrefix(rule.Source, "172.17.") ||
		strings.HasPrefix(rule.Source, "172.18.") ||
		strings.HasPrefix(rule.Source, "172.19.") ||
		strings.HasPrefix(rule.Destination, "172.17.") ||
		strings.HasPrefix(rule.Destination, "172.18.") ||
		strings.HasPrefix(rule.Destination, "172.19.") {
		return true
	}

	return false
}

func (m *FirewallManager) parseIptablesLine(line, chain string) models.FirewallRule {
	rule := models.FirewallRule{Chain: chain}

	fields := strings.Fields(line)
	if len(fields) < 6 {
		return rule
	}

	// num pkts bytes target prot opt in out source destination [extra]
	// Skip line number (first field if numeric)
	startIdx := 0
	if _, err := fmt.Sscanf(fields[0], "%d", new(int)); err == nil {
		startIdx = 1
	}

	if len(fields) > startIdx+3 {
		rule.Target = fields[startIdx+2]
	}
	if len(fields) > startIdx+4 {
		rule.Protocol = fields[startIdx+3]
	}
	if len(fields) > startIdx+5 {
		rule.InterfaceIn = fields[startIdx+5]
	}
	if len(fields) > startIdx+6 {
		rule.InterfaceOut = fields[startIdx+6]
	}
	if len(fields) > startIdx+7 {
		rule.Source = fields[startIdx+7]
	}
	if len(fields) > startIdx+8 {
		rule.Destination = fields[startIdx+8]
	}

	// Parse port from extra fields (dpt:80)
	for _, field := range fields {
		if strings.HasPrefix(field, "dpt:") {
			portStr := strings.TrimPrefix(field, "dpt:")
			var port int
			fmt.Sscanf(portStr, "%d", &port)
			rule.Port = port
		}
	}

	return rule
}

// GetNATStatus returns NAT/masquerade status
func (m *FirewallManager) GetNATStatus() map[string]interface{} {
	return map[string]interface{}{
		"enabled":    m.isNATEnabled(),
		"interface":  m.cfg.WANInterface,
		"ip_forward": m.isIPForwardEnabled(),
	}
}

func (m *FirewallManager) isNATEnabled() bool {
	cmd := exec.Command("iptables", "-t", "nat", "-L", "POSTROUTING", "-n", "-v")
	output, err := cmd.Output()
	if err != nil {
		return false
	}
	return strings.Contains(string(output), "MASQUERADE")
}

func (m *FirewallManager) isIPForwardEnabled() bool {
	data, err := os.ReadFile("/proc/sys/net/ipv4/ip_forward")
	if err != nil {
		// Try host-mounted path
		data, err = os.ReadFile("/host/proc/sys/net/ipv4/ip_forward")
		if err != nil {
			return false
		}
	}
	return strings.TrimSpace(string(data)) == "1"
}

// EnableNAT enables NAT/masquerade
func (m *FirewallManager) EnableNAT() *models.SuccessResponse {
	// Enable IP forwarding
	exec.Command("sysctl", "-w", "net.ipv4.ip_forward=1").Run()

	// Add MASQUERADE rule
	cmd := exec.Command("iptables", "-t", "nat", "-A", "POSTROUTING",
		"-o", m.cfg.WANInterface, "-j", "MASQUERADE")
	if err := cmd.Run(); err != nil {
		return &models.SuccessResponse{Status: "error", Message: err.Error()}
	}

	// Add FORWARD rules
	exec.Command("iptables", "-A", "FORWARD", "-i", m.cfg.WANInterface,
		"-o", m.cfg.APInterface, "-m", "state", "--state", "RELATED,ESTABLISHED",
		"-j", "ACCEPT").Run()
	exec.Command("iptables", "-A", "FORWARD", "-i", m.cfg.APInterface,
		"-o", m.cfg.WANInterface, "-j", "ACCEPT").Run()

	return &models.SuccessResponse{Status: "success", Message: "NAT enabled"}
}

// DisableNAT disables NAT/masquerade
func (m *FirewallManager) DisableNAT() *models.SuccessResponse {
	// Remove MASQUERADE rules
	exec.Command("iptables", "-t", "nat", "-D", "POSTROUTING",
		"-o", m.cfg.WANInterface, "-j", "MASQUERADE").Run()

	return &models.SuccessResponse{Status: "success", Message: "NAT disabled"}
}

// AllowPort allows incoming traffic on a port
func (m *FirewallManager) AllowPort(port int, protocol, comment string) *models.SuccessResponse {
	args := []string{"-A", "INPUT", "-p", protocol, "--dport", fmt.Sprintf("%d", port), "-j", "ACCEPT"}
	if comment != "" {
		args = append(args, "-m", "comment", "--comment", comment)
	}

	cmd := exec.Command("iptables", args...)
	if err := cmd.Run(); err != nil {
		return &models.SuccessResponse{Status: "error", Message: err.Error()}
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: fmt.Sprintf("Allowed port %d/%s", port, protocol),
	}
}

// BlockPort blocks incoming traffic on a port
func (m *FirewallManager) BlockPort(port int, protocol string) *models.SuccessResponse {
	cmd := exec.Command("iptables", "-A", "INPUT", "-p", protocol,
		"--dport", fmt.Sprintf("%d", port), "-j", "DROP")
	if err := cmd.Run(); err != nil {
		return &models.SuccessResponse{Status: "error", Message: err.Error()}
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: fmt.Sprintf("Blocked port %d/%s", port, protocol),
	}
}

// RemovePortRule removes a port rule
func (m *FirewallManager) RemovePortRule(port int, protocol, action string) *models.SuccessResponse {
	cmd := exec.Command("iptables", "-D", "INPUT", "-p", protocol,
		"--dport", fmt.Sprintf("%d", port), "-j", action)
	if err := cmd.Run(); err != nil {
		return &models.SuccessResponse{Status: "error", Message: err.Error()}
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: fmt.Sprintf("Removed port rule %d/%s", port, protocol),
	}
}

// SaveRules saves iptables rules to file
func (m *FirewallManager) SaveRules() *models.SuccessResponse {
	// Save filter rules
	filterCmd := exec.Command("sh", "-c", "iptables-save > /etc/iptables/rules.v4")
	if err := filterCmd.Run(); err != nil {
		// Try alternative path
		filterCmd = exec.Command("sh", "-c", "iptables-save > /etc/iptables.rules")
		filterCmd.Run()
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: "Firewall rules saved",
	}
}

// RestoreRules restores iptables rules from file
func (m *FirewallManager) RestoreRules() *models.SuccessResponse {
	// Try primary path
	cmd := exec.Command("sh", "-c", "iptables-restore < /etc/iptables/rules.v4")
	if err := cmd.Run(); err != nil {
		// Try alternative path
		cmd = exec.Command("sh", "-c", "iptables-restore < /etc/iptables.rules")
		if err := cmd.Run(); err != nil {
			return &models.SuccessResponse{Status: "error", Message: "No saved rules found"}
		}
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: "Firewall rules restored",
	}
}

// SetIPForward enables or disables IP forwarding
func (m *FirewallManager) SetIPForward(enabled bool) *models.SuccessResponse {
	value := "0"
	if enabled {
		value = "1"
	}

	cmd := exec.Command("sysctl", "-w", fmt.Sprintf("net.ipv4.ip_forward=%s", value))
	if err := cmd.Run(); err != nil {
		return &models.SuccessResponse{Status: "error", Message: err.Error()}
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: fmt.Sprintf("IP forwarding set to %s", value),
	}
}

// ResetFirewall resets firewall to default (accept all)
func (m *FirewallManager) ResetFirewall() *models.SuccessResponse {
	tables := []string{"filter", "nat", "mangle"}
	for _, table := range tables {
		exec.Command("iptables", "-t", table, "-F").Run()
	}

	chains := []string{"INPUT", "FORWARD", "OUTPUT"}
	for _, chain := range chains {
		exec.Command("iptables", "-P", chain, "ACCEPT").Run()
	}

	return &models.SuccessResponse{
		Status:  "success",
		Message: "Firewall reset to defaults",
	}
}

// Common service ports
var ServicePorts = map[string]struct {
	Port     int
	Protocol string
}{
	"ssh":   {22, "tcp"},
	"http":  {80, "tcp"},
	"https": {443, "tcp"},
	"dns":   {53, "udp"},
}

// AllowService allows traffic for a common service by name
func (m *FirewallManager) AllowService(service string) *models.SuccessResponse {
	svc, ok := ServicePorts[service]
	if !ok {
		return &models.SuccessResponse{Status: "error", Message: fmt.Sprintf("Unknown service: %s", service)}
	}
	return m.AllowPort(svc.Port, svc.Protocol, fmt.Sprintf("Allow %s", service))
}

// GetBlockedMACs returns list of blocked MAC addresses
func (m *FirewallManager) GetBlockedMACs() []string {
	var blocked []string

	cmd := exec.Command("iptables", "-L", "INPUT", "-n", "-v")
	output, err := cmd.Output()
	if err != nil {
		return blocked
	}

	macRegex := regexp.MustCompile(`MAC\s+([0-9A-Fa-f:]{17})`)
	matches := macRegex.FindAllStringSubmatch(string(output), -1)

	seen := make(map[string]bool)
	for _, match := range matches {
		if len(match) > 1 {
			mac := strings.ToLower(match[1])
			if !seen[mac] {
				seen[mac] = true
				blocked = append(blocked, mac)
			}
		}
	}

	return blocked
}
